Starting weekly assessment for Xiaosheng, Week3

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 64.57 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week1, Week7, Assessment, HPC, Week2, .git, BigProject, ModelFitting, Week3

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~
*.tmp
.vscode

# Python
*.py[co]
__pycache__/

#Jupyter
.ipynb_checkpoints/

# R History files
.Rhistory
.Rapp.history

# R Session Data files
.RData
Rplots.pdf

## Core latex/pdflatex auxiliary files:
*.aux
*.lof
*.log
*.lot
*.fls
*.out
*.toc
*.fmt
*.fot
*.cb
*.cb2
.*.lb

## Intermediate documents:
*.dvi
*.xdv
*-converted-to.*
# these rules might exclude image files for figures etc.
# *.ps
# *.eps
# *.pdf

## Generated if empty string is given at "Please type another file name for output:"
.pdf

## Bibliography auxiliary files (bibtex/biblatex/biber):
*.bbl
*.bcf
*.blg
*-blx.aux
*-blx.bib
*.run.xml

## Build tool auxiliary files:
*.fdb_latexmk
*.synctex
*.synctex(busy)
*.synctex.gz
*.synctex.gz(busy)
*.pdfsync
**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************

# **CMEE 2018-2019 Coursework Repository**

![ice-bear](http://cdn2us.denofgeek.com/sites/denofgeekus/files/styles/article_width/public/2017/08/we-bare-bears-grizz-panda-ice-bear.png?itok=ZAm1gpyl)


## Contents
### [Week1](https://github.com/Luoxsh6/CMEECourseWork/tree/master/Week1)
  - introduction to Unix and Linux
  - Shell scripting
  - Version Control with Git
  - LaTeX

### [Week2](https://github.com/Luoxsh6/CMEECourseWork/tree/master/Week2)
  - Python basics
  - Python I/O
  - Python programs
  - Control statements
  - Debugging

### [Week3](https://github.com/Luoxsh6/CMEECourseWork/tree/master/Week3)
  - R basics
  - Vectorization
  - Debugging
  - Sweave and knitr
  - Data wrangling
  - Data visualization
  - qplot and ggplot
 
### [Week7](https://github.com/Luoxsh6/CMEECourseWork/tree/master/Week7)
  - Scipy
  - Plotting with matplotlib
  - Profiling
  - Networks
  - Regular expressions
  - Build workflows

## Prerequisites
 
### Ubuntu 16.04
 
#### Python 3.6
#### Modules
'pickle' 'numpy' 'scipy' 'pandas' 'networkx' 'matplotlib'
 
### R 3.5.1
#### Packages
'lattice' 'reshape2' 'dplyr' 'tidyr' 'ggplot2' 'maps' 'knitr'

### LaTeX

**To Be Continued...************************************************************************

======================================================================
Looking for the weekly directories...

Found 4 weekly directories: Week1, Week2, Week3, Week7

The Week3 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK3...

Found the following directories: code, data, results

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# Week3
`R`

This is a rookie's R computing project   :ghost:  :ghost:

***

## Getting Started
As you can see, it has three directory.
- **data** for the data used for the Code
- **code** for the code operating the Data
- **results** for the results output from code

### Prerequisites

Some basic concepts about R

### Installation
Ubuntu 16.04  
Rstudio R 3.4.4
### Usage example
- sample.R
    ```R
    ##run a simulation that involves sampling from a population
    ```
- basic_io.R
    ```R
    ##A simple script to illustrate R input-output
    ```

- boilerplate.R
    ```R
    ##A boilerplate R script
    ```

- control.R
    ```R
    ##Some code exemplifying control flow constructs in R 
    ```

- break.R
    ```R
    ##function break
    ```

- next.R
    ```R
    ##function next
    ```

- TreeHeight.R
    ```R
    ##Modify the script TreeHeight.R, Loads trees.csv and ouput file called ##TreeHts.csv in results that contains the calculated tree heights
    ```

- get_TreeHeight.R
    ```R
    ##get input file name in output file
    ##using path to the input file  
    ```

- run_get_TreeHeight.sh
    ```bash
    ##tests get_TreeHeight.R and get_TreeHeight.py
    ```
- Vectorize1.R
    ```R
    ##SumAllElements() vs sum()
    ```

- preallocate.R
    ```R
    a <- rep(NA, 1000000)
    ``` 

- apply1.R
- apply2.R
    ```R
    ##The *apply family of functions
    ```

- Vectorize2.R
    ```R
    ##come up with a better solution to Ricker using vectorization 
    ```

- browse.R
    ```R
    ##debugging 
    ```

- TAutoCorr.R
    ```R
    ##Autocorrelation in weather
    ```

- Mapping.R
    ```R
    ##map the Global Population Dynamics Database
    ```

- DataWrangTidy.R
    ```R
    ##Convert from wide to long format
    ```

- PP_Lattice.R
    ```R
    ##result in three files called Pred_Lattice.pdf, Prey_Lattice.pdf, and SizeRatio_Lattice.pdf
    ```

- PP_Regress.R
- PP_Regress_loc.R
    ```R
    ##using dplyr to group_by lm 
    ```

___
## Authors

**Xiaosheng Luo** - *MRes CMEE* - [xiaosheng.luo18@imperial.ac.uk](xiaosheng.luo18@imperial.ac.uk)

## License

This work is licensed under a [Creative Commons Attribution 3.0 Unported License.](http://creativecommons.org/licenses/by/3.0/)
**********************************************************************

Found following files in results directory: TreeHts.csv, PP_Regress_loc.csv, Girko.pdf, PP_Results.csv, PP_Regress.pdf, trees_treeheights.csv, Pred_Lattice.pdf, Prey_Lattice.pdf, MyLinReg.pdf, PP_Regress.csv, TAutoCorr.pdf, SizeRatio_Lattice.pdf, MyData.csv...
ideally, Results directory should be empty other than, perhaps, a readme. 

Found 31 code files: browse.R, PP_Regress.R, Vectorize2.py, apply1.R, sample.R, Vectorize_Compare.sh, run_get_TreeHeight.sh, get_TreeHeight.py, Mapping.R, boilerplate.R, TreeHeight.R, PP_Lattice.R, next.R, Girko.R, Vectorize1.R, break.R, plotLin.R, basic_io.R, Vectorize1.py, try.R, apply2.R, get_TreeHeight.R, TAutoCorr.R, Vectorize2.R, DataWrangTidy.R, preallocate.R, PP_Regress_loc.R, DataWrang.R, TAutoCorr.tex, MyBars.R, control.R

Current Points = 100

======================================================================
Testing script/code files...

======================================================================
Inspecting script file browse.R...

File contents are:
**********************************************************************
Exponential <- function(N0 = 1, r = 1, generations = 10){
  # Runs a simulation of exponential growth
  # Returns a vector of length generations

  N <- rep(NA, generations)    # Creates a vector of NA

  N[1] <- N0
  for (t in 2:generations){
    N[t] <- N[t-1] * exp(r)
    browser()
  }
  return (N)
}

plot(Exponential(), type="l", main="Exponential growth")**********************************************************************

Testing browse.R...

Output (only first 500 characters): 

**********************************************************************
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********************************************************************

Code ran without errors

Time consumed = 0.11001s

======================================================================
Inspecting script file PP_Regress.R...

File contents are:
**********************************************************************
# Author: Xiaosheng Luo <Xiaosheng.luo18@imperial.ac.uk>
# Date: October 2018
# Desc: ggplot practicle for data visualisation

# clear environment
rm(list=ls())

# Load required packages #
require(ggplot2)
require(dplyr)

# load the data
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv", header = TRUE)

#Creating the correct graph
p <- ggplot(MyDF, aes(x = Prey.mass, y = Predator.mass, col = Predator.lifestage)) + 
  geom_point(shape = 3) + geom_smooth(method = 'lm', fullrange = TRUE) + facet_grid(Type.of.feeding.interaction ~ .) + 
  scale_y_continuous(trans = "log10") + scale_x_continuous(trans = "log10") + xlab("Prey Mass in grams") + ylab("Predator Mass in grams") + 
  theme_bw() + theme(legend.position="bottom")+ coord_fixed(ratio = 0.3)+ guides(color = guide_legend(nrow=1))

# show the plot
p

# save plot
pdf("../results/PP_Regress.pdf", 11.7, 8.3) 
print(p)
dev.off()

# work out stats
# define a function return the summary of lm as vector
Myfun <- function(y,z) {
  x <- lm(log(y)~log(z))
  intercept = summary(x)$coefficients[1]
  slope = summary(x)$coefficients[2]
  r_sq = summary(x)$r.squared
  p.value = summary(x)$coefficients[8]
  f.statistic = summary(x)$fstatistic[1]
  df <- c(slope, intercept, r_sq, f.statistic, p.value)
  return(df)
}

# use dplyr group_by to output the results
results <- MyDF %>% group_by(Type.of.feeding.interaction,Predator.lifestage ) %>%
  summarise(Slop = Myfun(Predator.mass, Prey.mass)[1],
            Intercept = Myfun(Predator.mass, Prey.mass)[2],
            Rsquared = Myfun(Predator.mass, Prey.mass)[3],
            Fvalue = Myfun(Predator.mass, Prey.mass)[4], 
            Pvalue = Myfun(Predator.mass, Prey.mass)[5])

#write into a csv file in teh results direction
write.csv(results, "../results/PP_Regress.csv", row.names = FALSE)**********************************************************************

Testing PP_Regress.R...

Output (only first 500 characters): 

**********************************************************************
pdf 
  2 

**********************************************************************

Encountered error:
Loading required package: ggplot2
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Warning message:
In qt((1 - level)/2, df) : NaNs produced
Warning message:
In qt((1 - level)/2, df) : NaNs produced

======================================================================
Inspecting script file Vectorize2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""A python version of Vectorize2.R, run the stochastic Ricker model using loop and vectorization"""

__author__ = 'Xiaosheng Luo (xiaosheng.luo18@imperial.ac.uk)'
__version__ = '0.0.1'

# import modules
import numpy as np
import time


def stochrick(p0=np.random.uniform(.5, 1.5, size=1000), r=1.2, K=1, sigma=0.2, numyears=100):
    """Calculate the Ricker model with looping"""

    N = np.zeros((numyears, p0.shape[0]))  # initialize
    N[0, ] = p0[0]

    for pop in range(p0.shape[0]):  # loop through the populations
        for yr in range(1, numyears):  # for each pop, loop through the years
            N[yr, pop] = N[yr-1, pop] * \
                np.exp(r*(1-N[yr-1, pop]/K)) + np.random.normal(0, sigma, 1)

    return (N)


def stochrickvect(p0=np.random.uniform(.5, 1.5, size=1000), r=1.2, K=1, sigma=0.2, numyears=100):
    """Calculate the Ricker model with vectorization"""

    N = np.zeros((numyears, p0.shape[0]))  # initialize
    N[0, ] = p0[0]

    for yr in range(1, numyears):  # for each pop, loop through the years
        N[yr] = N[yr-1] * \
            np.exp(r*(1-N[yr-1]/K)) + np.random.normal(0, sigma, 1)

    return (N)


# time consuming comparison
# Loop verion
tic = time.time()
loop = stochrick()
toc = time.time()

print("Loop takes: " + str(1000*(toc - tic)) + " ms")

# vectorized version
tic = time.time()
vec = stochrickvect()
toc = time.time()

print("Vectorized takes: " + str(1000*(toc - tic)) + " ms")


# The np.exp function rises a overflow warning ignored by numpy setting.
np.seterr(all='ignore')
**********************************************************************

Testing Vectorize2.py...

Vectorize2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Loop takes: 737.1125221252441 ms
Vectorized takes: 9.720563888549805 ms

**********************************************************************

Code ran without errors

Time consumed = 0.88888s

======================================================================
Inspecting script file apply1.R...

File contents are:
**********************************************************************
## apply: applying the same function to rows/colums of a matrix

## Build a random matrix
M <- matrix(rnorm(100), 10, 10)

## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print (RowMeans)

## Now the variance
RowVars <- apply(M, 1, var)
print (RowVars)

## By column
ColMeans <- apply(M, 2, mean)
print (ColMeans)
**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 

**********************************************************************
 [1] -0.2102057  0.5934430 -0.5930568  0.2053820 -0.4942521  0.5955267
 [7] -0.1862158 -0.6504025 -0.4063172  0.1793074
 [1] 0.4909253 0.2354661 0.5696940 0.5466606 0.4567108 1.1176817 1.2428300
 [8] 1.4230713 0.8838370 1.8968313
 [1] -0.4082183  0.1068838 -0.0925139  0.2962323  0.1276462 -0.7655355
 [7]  0.3599434 -0.3299833 -0.1032090 -0.1580366

**********************************************************************

Code ran without errors

Time consumed = 0.07173s

======================================================================
Inspecting script file sample.R...

File contents are:
**********************************************************************
## run a simulation that involves sampling from a population

x <- rnorm(50) #Generate your population
doit <- function(x){
    x <- sample(x, replace = TRUE)
    if(length(unique(x)) > 30) { #only take mean if sample was sufficient
         print(paste("Mean of this sample was:", as.character(mean(x))))
         } 
    }

## Run 100 iterations using vectorization:
result <- lapply(1:100, function(i) doit(x))

## Or using a for loop:
result <- vector("list", 100) #Preallocate/Initialize
for(i in 1:100) {
    result[[i]] <- doit(x)
}**********************************************************************

Testing sample.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Mean of this sample was: 0.257433984073253"
[1] "Mean of this sample was: 0.396341431808488"
[1] "Mean of this sample was: 0.192860333269186"
[1] "Mean of this sample was: 0.315064903782542"
[1] "Mean of this sample was: 0.406302765280859"
[1] "Mean of this sample was: 0.168993699965971"
[1] "Mean of this sample was: 0.303498000221816"
[1] "Mean of this sample was: 0.316519033117898"
[1] "Mean of this sample was: 0.491899598837092"
[1] "Mean of this sample was: 0.391249246887465"
[1] "Mean o
**********************************************************************

Code ran without errors

Time consumed = 0.10232s

======================================================================
Inspecting script file Vectorize_Compare.sh...

File contents are:
**********************************************************************
#!/bin/bash
# Script: Vectorize_Compare.sh
# Author: Xiaosheng Luo (xiaosheng.luo18@imperial.ac.uk)
# Desc: Compare computational speed between loop and vectorization
# Arguments: none
# Date: Oct 2018

echo -e "\n Computing time for Vectorize1.R \n"
Rscript Vectorize1.R
echo -e "-------------------------------------"
echo -e "\n Computing time for Vectorize1.py \n"
python3 Vectorize1.py
echo -e "-------------------------------------"
echo -e "\n Computing time for Vectorize2.R \n"
Rscript Vectorize2.R
echo -e "-------------------------------------"
echo -e "\n Computing time for Vectorize2.py \n"
python3 Vectorize2.py**********************************************************************

Testing Vectorize_Compare.sh...

Output (only first 500 characters): 

**********************************************************************

 Computing time for Vectorize1.R 

   user  system elapsed 
  0.080   0.000   0.082 
   user  system elapsed 
  0.004   0.000   0.001 
-------------------------------------

 Computing time for Vectorize1.py 

Looping sum is: 500467.271486
Loop takes: 292.72961616516113 ms
Vectorized sum is: 500467.271486
Vectorized takes: 0.5941390991210938 ms
-------------------------------------

 Computing time for Vectorize2.R 

[1] "Vectorized Stochastic Ricker takes:"
   user  system elapsed 
  0.048   0.
**********************************************************************

Code ran without errors

Time consumed = 1.57009s

======================================================================
Inspecting script file run_get_TreeHeight.sh...

File contents are:
**********************************************************************
#!/bin/bash
# Author: Xiaosheng Luo xiaosheng.luo18@imperial.ac.uk
# Script: run_get_TreeHeight.sh
# Desc: simple boilerplate for shell scripts
# Arguments: none
# Date: Oct 2018

#!/bin/bash    

P1=$1  
  
DEFAULT_P1="../data/trees.csv"  

    
if [ "$P1" == "" ]; then  
    P1=$DEFAULT_P1  
fi  


Rscript get_TreeHeight.R $P1 
python3 get_TreeHeight.py $P1**********************************************************************

Testing run_get_TreeHeight.sh...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Exit

======================================================================
Inspecting script file get_TreeHeight.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""A function calculates heights of trees given distance of each tree from its base and angle to its top, using the trigonometric formula"""

__author__ = 'Xiaosheng Luo (xiaosheng.luo18@imperial.ac.uk)'
__version__ = '0.0.1'

# import modules
import sys
import pandas as pd
import numpy as np
import ntpath


def TreeHeight(data):
    """Calculate treeheights from distance and angle of elevation. Input(degrees, distance), output height"""

    degrees = data['Angle.degrees']
    distance = data['Distance.m']
    radians = np.deg2rad(degrees)
    height = distance * np.tan(radians)
    data['height'] = height
    return data


def ReadFile(inputpath):
    """Read and load file from path fpath, and return pandas data"""

    data = pd.read_csv(inputpath)
    return data


def SaveFile(outputdata, inputpath):
    """Save data into a '../results' directory with filename InputFileName_treeheights.csv"""

    name = ntpath.basename(inputpath).split('.')[0]
    filename = name + r'_treeheights.csv'
    path = '../results/' + filename
    outputdata.to_csv(path, index=False)


def main(argv):
    data = ReadFile(sys.argv[1])
    outputdata = TreeHeight(data)
    SaveFile(outputdata, sys.argv[1])


if(__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit("Exit")
**********************************************************************

Testing get_TreeHeight.py...

get_TreeHeight.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Traceback (most recent call last):
  File "get_TreeHeight.py", line 49, in <module>
    status = main(sys.argv)
  File "get_TreeHeight.py", line 43, in main
    data = ReadFile(sys.argv[1])
IndexError: list index out of range

======================================================================
Inspecting script file Mapping.R...

File contents are:
**********************************************************************
# map the Global Population Dynamics Database

rm(list=ls())

# load required packages

require(maps)
# load in the data
load("../data/GPDDFiltered.RData")
gpdd <- as.data.frame(gpdd)
# set the map
map(database = "world", fill = T)
# put the points on the map.
points(x = gpdd$long, y = gpdd$lat, pch = 21, bg = gpdd$common.name)

# A more beautiful map
# require(leaflet)
# m<- leaflet(gpdd)
# m<- addTiles(m)
# m<- setView(m,lng=0.00,lat=20.00,zoom=2)
# addCircleMarkers(m,lng=~long,lat=~lat,radius =0.1, col= 27, fill = TRUE)

##Biases: The data is mainly focusing on western regions, specifically North America and Europe, while Southern Africa and Japan shows only a single point. ##Obviously such data is highly biased against the assessment of biodiversity except Western regions.


**********************************************************************

Testing Mapping.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Loading required package: maps

======================================================================
Inspecting script file boilerplate.R...

File contents are:
**********************************************************************
# A boilerplate R script

MyFunction <- function(Arg1, Arg2){

  # Statements involving Arg1, Arg2:
  print(paste("Argument", as.character(Arg1), "is a", class(Arg1))) # print Arg1's type
  print(paste("Argument", as.character(Arg2), "is a", class(Arg2))) # print Arg2's type

  return (c(Arg1, Arg2)) #this is optional, but very useful
}

MyFunction(1,2) #test the function
MyFunction("Riki","Tiki") #A different test
**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Argument 1 is a numeric"
[1] "Argument 2 is a numeric"
[1] 1 2
[1] "Argument Riki is a character"
[1] "Argument Tiki is a character"
[1] "Riki" "Tiki"

**********************************************************************

Code ran without errors

Time consumed = 0.08536s

======================================================================
Inspecting script file TreeHeight.R...

File contents are:
**********************************************************************
# This function calculates heights of trees given distance of each tree 
# from its base and angle to its top, using  the trigonometric formula 
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"

TreeHeight <- function(degrees, distance){
  radians <- degrees * pi / 180
  height <- distance * tan(radians)
  # print(paste("Tree height is:", height))
  return (height)
}


trees <- read.csv(file = "../data/trees.csv")
degrees <- trees[,3]
distance <- trees[,2]
Tree.Height.m <- TreeHeight(degrees,distance)
trees$Tree.Height.m <- Tree.Height.m    #create a new column 
write.csv(trees, file="../results/TreeHts.csv", row.names=FALSE)

**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.08080s

======================================================================
Inspecting script file PP_Lattice.R...

File contents are:
**********************************************************************
rm(list=ls())
require(lattice)
require(plyr)

MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv")

pdf("../results/Pred_Lattice.pdf", 11.7, 8.3) # ready to save 1st graph
histogram(~log(Predator.mass), data =MyDF)
dev.off()

pdf("../results/Prey_Lattice.pdf", 11.7, 8.3) # graph 2
histogram(~log(Prey.mass), data = MyDF)
dev.off()

pdf("../results/SizeRatio_Lattice.pdf", 11.7, 8.3) # graph 3
histogram(~log((Predator.mass) /(Prey.mass)), data =MyDF)
dev.off()

a <-log(MyDF$Predator.mass)
b <-log(MyDF$Prey.mass)
c <-log((MyDF$Predator.mass) /(MyDF$Prey.mass))
d <- MyDF$Type.of.feeding.interaction
f <-data.frame(feeding.type=d, log.Predator.mass=a,log.Prey.mass=b,ratio=c)

#dmean <- tapply(a, d, mean)

# log.Predator.mass <- ddply(f, .(feeding.type), summarize, log.Predator.mass.mean = round(mean(log.Predator.mass), 2), log.Predator.mass.median = round(median(log.Predator.mass), 2))

# log.Prey.mass <- ddply(f, .(feeding.type), summarize, log.Prey.mass.mean = round(mean(log.Prey.mass), 2), log.Prey.mass.median = round(median(log.Prey.mass), 2))

# ratio <- ddply(f, .(feeding.type), summarize, ratio.mean = round(mean(ratio), 2), ratio.median = round(median(ratio), 2))

# # merge three data.frame
# mix <- merge(log.Predator.mass, log.Prey.mass)
# result <- merge(mix, ratio)


PP_Results <- ddply(MyDF, ~ Type.of.feeding.interaction, summarize, 
                    mean_mass_pred = mean(Predator.mass), median_mass_pred = median(Predator.mass), 
                    mean_mass_prey = mean(Prey.mass), median_mass_prey = median(Prey.mass),
                    mean_ppsize_ratio = mean(log(Predator.mass/Prey.mass)), 
                    median_ppsize_ratio = median(log(Predator.mass/Prey.mass)))


write.csv(PP_Results,"../results/PP_Results.csv", row.names=FALSE)**********************************************************************

Testing PP_Lattice.R...

Output (only first 500 characters): 

**********************************************************************
null device 
          1 
null device 
          1 
null device 
          1 

**********************************************************************

Encountered error:
Loading required package: lattice
Loading required package: plyr

======================================================================
Inspecting script file next.R...

File contents are:
**********************************************************************
for (i in 1:10) {
  if ((i %% 2) == 0) 
    next # pass to next iteration of loop 
  print(i)
}
**********************************************************************

Testing next.R...

Output (only first 500 characters): 

**********************************************************************
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors

Time consumed = 0.08774s

======================================================================
Inspecting script file Girko.R...

File contents are:
**********************************************************************
# Author: xiaosheng.luo18@imperial.ac.uk
# Script: Girko.R
# Description: explore matrix plot
# Date: Oct 2018

build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)  
  return(data.frame(x = x, y = y))
}


N <- 250 # Assign size of the matrix

M <- matrix(rnorm(N * N), N, N) # Build the matrix

eigvals <- eigen(M)$values # Find the eigenvalues

eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe

my_radius <- sqrt(N) # The radius of the circle is sqrt(N)

ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse

names(ellDF) <- c("Real", "Imaginary") # rename the columns


# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  geom_point(shape = I(3)) +
  theme(legend.position = "none")

# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))

# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))
p

pdf("../results/Girko.pdf")
print(p)
dev.off()**********************************************************************

Testing Girko.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Error in ggplot(eigDF, aes(x = Real, y = Imaginary)) : 
  could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file Vectorize1.R...

File contents are:
**********************************************************************
M <- matrix(runif(1000000),1000,1000)

SumAllElements <- function(M){
  Dimensions <- dim(M)
  Tot <- 0
  for (i in 1:Dimensions[1]){
    for (j in 1:Dimensions[2]){
      Tot <- Tot + M[i,j]
      }}        
    return (Tot)
}
## This on my computer takes about 1 sec
print(system.time(SumAllElements(M)))
## While this takes about 0.01 sec
print(system.time(sum(M)))
**********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 

**********************************************************************
   user  system elapsed 
  0.080   0.000   0.083 
   user  system elapsed 
  0.000   0.000   0.001 

**********************************************************************

Code ran without errors

Time consumed = 0.21929s

======================================================================
Inspecting script file break.R...

File contents are:
**********************************************************************
i <- 0 #Initialize i
    while(i < Inf) {
        if (i == 20) {
            break } # Break out of the while loop! 
        else { 
            cat("i equals " , i , " \n")
            i <- i + 1 # Update i
    }
}

**********************************************************************

Testing break.R...

Output (only first 500 characters): 

**********************************************************************
i equals  0  
i equals  1  
i equals  2  
i equals  3  
i equals  4  
i equals  5  
i equals  6  
i equals  7  
i equals  8  
i equals  9  
i equals  10  
i equals  11  
i equals  12  
i equals  13  
i equals  14  
i equals  15  
i equals  16  
i equals  17  
i equals  18  
i equals  19  

**********************************************************************

Code ran without errors

Time consumed = 0.09008s

======================================================================
Inspecting script file plotLin.R...

File contents are:
**********************************************************************
x <- seq(0, 100, by = 0.1)
y <- -4. + 0.25 * x +
  rnorm(length(x), mean = 0., sd = 2.5)

# and put them in a dataframe
my_data <- data.frame(x = x, y = y)

# perform a linear regression
my_lm <- summary(lm(y ~ x, data = my_data))

# plot the data
p <-  ggplot(my_data, aes(x = x, y = y,
                          colour = abs(my_lm$residual))
) +
  geom_point() +
  scale_colour_gradient(low = "black", high = "red") +
  theme(legend.position = "none") +
  scale_x_continuous(
    expression(alpha^2 * pi / beta * sqrt(Theta)))

# add the regression line
p <- p + geom_abline(
  intercept = my_lm$coefficients[1][1],
  slope = my_lm$coefficients[2][1],
  colour = "red")
# throw some math on the plot
p <- p + geom_text(aes(x = 60, y = 0,
                       label = "sqrt(alpha) * 2* pi"), 
                   parse = TRUE, size = 6, 
                   colour = "blue")

pdf("../results/MyLinReg.pdf")
print(p)
dev.off()
**********************************************************************

Testing plotLin.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Error in ggplot(my_data, aes(x = x, y = y, colour = abs(my_lm$residual))) : 
  could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file basic_io.R...

File contents are:
**********************************************************************
# A simple script to illustrate R input-output.  
# Run line by line and check inputs outputs to understand what is happening  

MyData <- read.csv("../data/trees.csv", header = TRUE) # import with headers

write.csv(MyData, "../results/MyData.csv") #write it out as a new file

write.table(MyData[1,], file = "../results/MyData.csv",append=TRUE, col.names=FALSE) # Append to it

write.csv(MyData, "../results/MyData.csv", row.names=TRUE) # write row names

write.table(MyData, "../results/MyData.csv", col.names=FALSE) # ignore column names
**********************************************************************

Testing basic_io.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.07889s

======================================================================
Inspecting script file Vectorize1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""A python version of Vectorize1.R, sums all elements in a matrix using loop and vectorization"""

__author__ = 'Xiaosheng Luo (xiaosheng.luo18@imperial.ac.uk)'
__version__ = '0.0.1'

# import modules
import numpy as np
import time


def SumbyLoop(M):
    """sum matrix elements by loop"""
    Tot = 0
    for i in range(M.shape[0]):
        for j in range(M.shape[1]):
            Tot += M[i][j]
    return Tot


def SumbyVec(M):
    """sum matrix elements by vectorization"""
    Tot = np.sum(M)
    return Tot


# initialize matrix M
np.random.seed(27)
M = np.random.rand(1000, 1000)

# time consuming comparison
# Loop verion
tic = time.time()
loop = SumbyLoop(M)
toc = time.time()

print("Looping sum is:", loop)
print("Loop takes: " + str(1000*(toc - tic)) + " ms")

# vectorized version
tic = time.time()
vec = SumbyVec(M)
toc = time.time()

print("Vectorized sum is:", vec)
print("Vectorized takes: " + str(1000*(toc - tic)) + " ms")
**********************************************************************

Testing Vectorize1.py...

Vectorize1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Looping sum is: 500467.271486
Loop takes: 254.92334365844727 ms
Vectorized sum is: 500467.271486
Vectorized takes: 0.6518363952636719 ms

**********************************************************************

Code ran without errors

Time consumed = 0.40748s

======================================================================
Inspecting script file try.R...

File contents are:
**********************************************************************
## run a simulation that involves sampling from a population with try

x <- rnorm(50) #Generate your population
doit <- function(x){
    x <- sample(x, replace = TRUE)
    if(length(unique(x)) > 30) {#only take mean if sample was sufficient
         print(paste("Mean of this sample was:", as.character(mean(x))))
        } 
    else {
        stop("Couldn't calculate mean: too few unique points!")
        }
    }

## Try using "try" with vectorization:
result <- lapply(1:100, function(i) try(doit(x), FALSE))

## Or using a for loop:
result <- vector("list", 100) #Preallocate/Initialize
for(i in 1:100) {
    result[[i]] <- try(doit(x), FALSE)
    }**********************************************************************

Testing try.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Mean of this sample was: 0.101464416274945"
[1] "Mean of this sample was: 0.051021032680806"
[1] "Mean of this sample was: 0.0725453660527608"
[1] "Mean of this sample was: 0.0962392300356658"
[1] "Mean of this sample was: 0.0674379863948712"
[1] "Mean of this sample was: 0.340229607697027"
[1] "Mean of this sample was: 0.079760615228648"
[1] "Mean of this sample was: 0.439694478178443"
[1] "Mean of this sample was: 0.109325621915602"
[1] "Mean of this sample was: 0.12194324657985"
[1] "Mean
**********************************************************************

Encountered error:
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!

======================================================================
Inspecting script file apply2.R...

File contents are:
**********************************************************************
SomeOperation <- function(v){ # What does this function do?
  if (sum(v) > 0){
    return (v * 100)
  }  
  return (v)
}

M <- matrix(rnorm(100), 10, 10)
print (apply(M, 1, SomeOperation))
**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 

**********************************************************************
             [,1]       [,2]       [,3]       [,4]        [,5]         [,6]
 [1,]  -64.223561  218.33010   50.08739 -0.2277680 -0.28067639  1.535203285
 [2,]  208.250495 -150.28369  106.18458 -0.3936582  0.06835154 -1.049833960
 [3,]   -2.866383   64.10227  -40.97157  0.7183707  0.72895537 -0.010091348
 [4,]  102.695561   26.03497 -100.98307 -0.3206982 -0.93387252  1.489230096
 [5,]   79.490848  -25.00452  -37.03509 -0.3728023 -1.77262214 -1.039128669
 [6,] -206.807655 -146.32600   87.45519 -1.78
**********************************************************************

Code ran without errors

Time consumed = 0.08990s

======================================================================
Inspecting script file get_TreeHeight.R...

File contents are:
**********************************************************************
# This function calculates heights of trees given distance of each tree 
# from its base and angle to its top, using  the trigonometric formula 
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"

TreeHeight <- function(degrees, distance){
  radians <- degrees * pi / 180
  height <- distance * tan(radians)
  # print(paste("Tree height is:", height))
  return (height)
}


args <- commandArgs(T)
# basename <- basename(args)
# file_dir <- paste("../data/", basename, sep="")
# filename <- unlist(strsplit(x=basename, split="\\."))[1]

trees <- read.csv(args[1], sep=",")

degrees <- trees[,3]
distance <- trees[,2]
Tree.Height.m <- TreeHeight(degrees,distance)
trees$Tree.Height.m <- Tree.Height.m    #create a new column 

filename= tools::file_path_sans_ext(basename(args[1])) # getting the filename
newfilename_dir <- paste("../results/", filename, "_treeheights.csv", sep="")

write.csv(trees, file=newfilename_dir, row.names=FALSE)



**********************************************************************

Testing get_TreeHeight.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Error in file(file, "rt") : cannot open the connection
Calls: read.csv -> read.table -> file
In addition: Warning message:
In file(file, "rt") : cannot open file 'NA': No such file or directory
Execution halted

======================================================================
Inspecting script file TAutoCorr.R...

File contents are:
**********************************************************************
rm(list=ls())

# load in the data
load("../data/KeyWestAnnualMeanTemperature.RData")
b <- dim(ats)[1]

temp1 <- ats[1:b-1,2]
temp2 <- ats[2:b,2]
tempCor <- cor(temp1,temp2)

result = rep(NA,10000)
for (i in 1:10000){
  samp <- sample(ats[,2],b)
  temp1 <- samp[1:b-1]
  temp2 <- samp[2:b]
  result[i] <- cor(temp1,temp2)
}

p_value = length(result[result>tempCor]) / length(result)
print(p_value)

plot.new()
pdf("../results/TAutoCorr.pdf", 11.7, 8.3) # Open blank pdf page using a relative path
hist(result, xlab = "correlation coefficient values", 
     ylab = "Frequency", col = rgb(0, 0, 1, 0.5), 
     main = "Temperature Coefficients", breaks = 27) 

legend('topleft', c("1000 random correlation coefficients", "successive year correlation"),
       fill=c(rgb(0, 0, 1, 0.5), rgb(1, 0, 0, 0.5)), cex = 0.8)

abline(v = tempCor, col = rgb(1, 0, 0, 0.5), lwd = 4) # successive year corr
dev.off()
**********************************************************************

Testing TAutoCorr.R...

Output (only first 500 characters): 

**********************************************************************
[1] 3e-04
pdf 
  2 

**********************************************************************

Code ran without errors

Time consumed = 0.65793s

======================================================================
Inspecting script file Vectorize2.R...

File contents are:
**********************************************************************
# Runs the stochastic (with gaussian fluctuations) Ricker Eqn .

rm(list=ls())

stochrick<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
  #initialize
  N<-matrix(NA,numyears,length(p0))
  N[1,]<-p0
  
  for (pop in 1:length(p0)) #loop through the populations
  {
    for (yr in 2:numyears) #for each pop, loop through the years
    {
      N[yr,pop]<-N[yr-1,pop]*exp(r*(1-N[yr-1,pop]/K)+rnorm(1,0,sigma))
    }
  }
 return(N)

}

# Now write another function called stochrickvect that vectorizes the above 
# to the extent possible, with improved performance: 

stochrickvect <- function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
  #initialize
  N<-matrix(NA,numyears,length(p0))
  N[1,]<-p0
  
    for (yr in 2:numyears) #for each pop, loop through the years
    {
      N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K)+rnorm(length(p0),0,sigma))
    }

 return(N)

}

print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))**********************************************************************

Testing Vectorize2.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Vectorized Stochastic Ricker takes:"
   user  system elapsed 
  0.048   0.000   0.050 

**********************************************************************

Code ran without errors

Time consumed = 0.12102s

======================================================================
Inspecting script file DataWrangTidy.R...

File contents are:
**********************************************************************
################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../data/PoundHillData.csv",header = F)) 

# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv",header = T, sep=";", stringsAsFactors = F)

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
fix(MyData) #you can also do this
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data

############# Convert from wide to long format  ###############
require(dplyr)
require(tidyr)

MyWrangledData <- TempData %>% gather(., Species, Count, -Cultivation, -Block, -Plot, -Quadrat) %>% 
    mutate( Cultivation = as.factor(Cultivation),
            Block = as.factor(Block),
            Plot = as.factor(Plot),
            Quadrat = as.factor(Quadrat),
            Species = as.factor(Species),
            Count = as.numeric(Count))                                                                                                                                                                                                                                                                                                                                                                                                         
str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############
hist(MyWrangledData$Count)
hist(log(MyWrangledData$Count))
boxplot(MyWrangledData$Count ~ MyWrangledData$Cultivation)
plot(MyWrangledData$Count ~ MyWrangledData$Cultivation)**********************************************************************

Testing DataWrangTidy.R...

Output (only first 500 characters): 

**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Code ran without errors

Time consumed = 10.00654s

======================================================================
Inspecting script file preallocate.R...

File contents are:
**********************************************************************
a <- rep(NA, 1000000)

for (i in 1:1000000) {
    a[i] <- i
}
print(a)**********************************************************************

Testing preallocate.R...

Output (only first 500 characters): 

**********************************************************************
    [1]     1     2     3     4     5     6     7     8     9    10    11    12
   [13]    13    14    15    16    17    18    19    20    21    22    23    24
   [25]    25    26    27    28    29    30    31    32    33    34    35    36
   [37]    37    38    39    40    41    42    43    44    45    46    47    48
   [49]    49    50    51    52    53    54    55    56    57    58    59    60
   [61]    61    62    63    64    65    66    67    68    69    70    71    72
   [73]    73    74  
**********************************************************************

Code ran without errors

Time consumed = 0.29705s

======================================================================
Inspecting script file PP_Regress_loc.R...

File contents are:
**********************************************************************
# Author: Xiaosheng Luo <Xiaosheng.luo18@imperial.ac.uk>
# Date: October 2018
# Desc: ggplot practicle for data visualisation

# clear environment
rm(list=ls())

# Load required packages #
require(ggplot2)
require(dplyr)

# load the data
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv", header = TRUE)

# work out stats
# define a function return the summary of lm as vector
Myfun <- function(y,z) {
  x <- lm(log(y)~log(z))
  intercept = summary(x)$coefficients[1]
  slope = summary(x)$coefficients[2]
  r_sq = summary(x)$r.squared
  p.value = summary(x)$coefficients[8]
  f.statistic = summary(x)$fstatistic[1]
  df <- c(slope, intercept, r_sq, f.statistic, p.value)
  return(df)
}

# use dplyr group_by to output the results
results <- MyDF %>% group_by(Type.of.feeding.interaction,Predator.lifestage, Location) %>%
  summarise(Slop = Myfun(Predator.mass, Prey.mass)[1],
            Intercept = Myfun(Predator.mass, Prey.mass)[2],
            Rsquared = Myfun(Predator.mass, Prey.mass)[3],
            Fvalue = Myfun(Predator.mass, Prey.mass)[4], 
            Pvalue = Myfun(Predator.mass, Prey.mass)[5])

#write into a csv file in the results direction
write.csv(results, "../results/PP_Regress_loc.csv", row.names = FALSE)**********************************************************************

Testing PP_Regress_loc.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Loading required package: ggplot2
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

There were 25 warnings (use warnings() to see them)

======================================================================
Inspecting script file DataWrang.R...

File contents are:
**********************************************************************
################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../data/PoundHillData.csv",header = F)) 

# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv",header = T, sep=";", stringsAsFactors = F)

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
fix(MyData) #you can also do this
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data

############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package

?melt #check out the melt function

MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")

MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############
**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 

**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Code ran without errors

Time consumed = 10.00670s

======================================================================
Inspecting script file TAutoCorr.tex...

File contents are:
**********************************************************************
\documentclass[12pt]{article}
    \usepackage{float}
    \usepackage{graphicx}
    \usepackage{svg}
    \title{Temperatures are Significantly Correlated between Successive Years on Key West}
    \author{Xiaosheng Luo}
    \date{22nd October 2018}
\begin{document}
\maketitle
Are temperatures of one year significantly correlated with the next year (successive years), across years in a given location? Using the temperature data for the Key West region in Florida over the 20th Century, the correlation value was computed between successive years and compared to a distribution of 10,000 randomly permuted time series correlations. As the measurements of successive time points are climactic variables they are not independent, making a standard p-value inappropriate. Instead, the approximate p-value was calculated by dividing the number of random sample correlations greater than the actual value by the entire sample size.
\begin{figure}[H]
	\centering
	\includegraphics[scale=.3]{../results/TAutoCorr.pdf}
	\caption{Temperature Coefficient Compared between Successive Years and Rondom Years in Key West, Florida from 1901-2000.}
\end{figure}


Figure above shows a graph with a significantly positive correlation between t and t-1 years. The positive correlation shown in the graph is further backed up by a pearsons correlation value of 0.33, which was attained by computing using the $cor()$ function in R, and the p value of $~ 0.003$ indicating these results are extremely unlikely to arise by chance. Hence, it can be interpreted that one years temperature is indicative of the subsequent years temperature.

\end{document}
**********************************************************************

Testing TAutoCorr.tex...

======================================================================
Inspecting script file MyBars.R...

File contents are:
**********************************************************************
a <- read.table("../data/Results.txt", header = TRUE)

a$ymin <- rep(0, dim(a)[1]) # append a column of zeros

# Print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y1,
  size = (0.5)
),
colour = "#E69F00",
alpha = 1/2, show.legend = FALSE)

# Print the second linerange
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y2,
  size = (0.5)
),
colour = "#56B4E9",
alpha = 1/2, show.legend = FALSE)

# Print the third linerange:
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y3,
  size = (0.5)
),
colour = "#D55E00",
alpha = 1/2, show.legend = FALSE)

# Annotate the plot with labels:
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))

# now set the axis labels, remove the legend, and prepare for bw printing
p <- p + scale_x_continuous("My x axis",
                            breaks = seq(3, 5, by = 0.05)) + 
  scale_y_continuous("My y axis") + 
  theme_bw() + 
  theme(legend.position = "none") 

pdf("../results/Girko.pdf")
print(p)
dev.off()**********************************************************************

Testing MyBars.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Error in ggplot(a) : could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file control.R...

File contents are:
**********************************************************************
## Some code exemplifying control flow constructs in R 

## If statement
a <- TRUE
if (a == TRUE){
    print ("a is TRUE")
    } else {
    print ("a is FALSE")
}

## On a single line
z <- runif(1) ##random number
if (z <= 0.5) {
    print ("Less than a quarter")
    }

## For loop using a sequence
for (i in 1:100){
    j <- i * i
    print(paste(i, " squared is", j ))
}

## For loop over vector of strings
for(species in c('Heliodoxa rubinoides', 
                 'Boissonneaua jardini', 
                 'Sula nebouxii'))
{
  print(paste('The species is', species))
}

## for loop using a vector
v1 <- c("a","bc","def")
for (i in v1){
    print(i)
}

## While loop
i <- 0
while (i<100){
    i <- i+1
    print(i^2)
}
**********************************************************************

Testing control.R...

Output (only first 500 characters): 

**********************************************************************
[1] "a is TRUE"
[1] "1  squared is 1"
[1] "2  squared is 4"
[1] "3  squared is 9"
[1] "4  squared is 16"
[1] "5  squared is 25"
[1] "6  squared is 36"
[1] "7  squared is 49"
[1] "8  squared is 64"
[1] "9  squared is 81"
[1] "10  squared is 100"
[1] "11  squared is 121"
[1] "12  squared is 144"
[1] "13  squared is 169"
[1] "14  squared is 196"
[1] "15  squared is 225"
[1] "16  squared is 256"
[1] "17  squared is 289"
[1] "18  squared is 324"
[1] "19  squared is 361"
[1] "20  squared is 400"
[1] "2
**********************************************************************

Code ran without errors

Time consumed = 0.09944s

======================================================================
======================================================================
Finished running scripts

Ran into 11 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 99.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!